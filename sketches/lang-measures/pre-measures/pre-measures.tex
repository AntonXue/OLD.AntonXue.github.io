\section{Pre-measures on Regular Languages}
We make a few observations.
First, languages are sets, and by extension so are regular languages.
Second, regular languages are closed under
finite union, finite intersection, and complement.
This means that regular languages therefore forms an algebra
closed under these operations.

\subsection{Counting Language Size}
The counting measure is well-known to be a measure,
and therefore a pre-measure, on the algebra of sets
with operations of union, intersection, and complement.
Therefore, it is straightforward to use the counting measure to measure
the size of a language \(\lang\).
Let us define the counting measure
\(\mucount \colon \langs \rightarrow \brackets{0, \infty}\)
on (regular) languages as follows:
\begin{align*}
  \mucount\parens{\lang} = \abs{\lang}
\end{align*}


\subsection{Counting Regular Expressions}
We have defined a convenient and natural way to count the size of a
(regular) language, and it remains for us to apply a similar
notion of (pre)-measure to the regular expressions that generate
these languages.
Recall that regular languages form an algebra, and therefore so do
the canonicalized regular expressions that generate them.
We wish to then define a counting pre-measure that counts the size
of a language given the regular expression form.
We attempt an inductive definition of
\(\premucount \colon \regexes \rightarrow \brackets{0, \infty}\)
on regular expressions as follows:
\begin{align*}
  \premucount\parens{\emptyset} = 0
    &\qquad \forall a \in \alphabet \st \premucount\parens{\braces{a}} = 1 \\
  \langmin\parens{\regex} = \regex_1 + \regex_2
    &\implies
      \premucount\parens{\reglang\parens{\regex}} =
        \premucount\parens{\reglang\parens{\regex_1}} +
        \premucount\parens{\reglang\parens{\regex_2}} \\
  \langmin\parens{\regex} = \regex_1 \cdot \regex_2
    &\implies
      \premucount\parens{\reglang\parens{\regex}} =
        \premucount\parens{\reglang\parens{\regex_1}} \cdot
        \premucount\parens{\reglang\parens{\regex_2}} \\
  \langmin\parens{\regex} = \regex_1 ^\ast
    &\implies
      \premucount\parens{\reglang\parens{\regex}}
        = \begin{cases}
            \infty & \quad \premucount\parens{\regex_1} > 0 \\
            0 & \quad \text{otherwise}
          \end{cases}
\end{align*}
Observe that almost by definition,
this counts precisely the size of the regular language generated by
the canonicalized regular expression.
In other words:
\begin{align*}
  \premucount\parens{\regex} = \mucount\parens{\reglang\parens{\regex}}
\end{align*}
We assume a bijection exists between canonicalized regular expressions
and regular languages (cite theorem from somewhere),
which means that this mapping is unique for each language.
Therefore, the counting pre-measure \(\premucount\)
defined on regular expressions this way is indeed a pre-measure.




% \subsection{Counting Pre-measure}
% Let \(\premucount \colon \alphabet^\ast \rightarrow \brackets{0, \infty}\)
% be the counting pre-measure defined for countable sets,
% such that:
% \begin{align*}
%   \premucount\parens{\lang} = \abs{\lang}
% \end{align*}
% 
% For a regular expression \(\regex\),
% we wish to say something meaningful about the pre-measure of its
% generated regular language
% \(\premucount\parens{\reglang\parens{\regex}}\).
% Then \(\premucount\) may be defined inductively in terms of
% the regular expression as follows:
% \begin{align*}
%   \premucount\parens{\emptyset} = 0
%     &\qquad \forall a \in \alphabet \st \premucount\parens{\braces{a}} = 1 \\
%   \langmin\parens{\regex} = \regex_1 + \regex_2
%     &\implies
%       \premucount\parens{\reglang\parens{\regex}} =
%         \premucount\parens{\reglang\parens{\regex_1}} +
%         \premucount\parens{\reglang\parens{\regex_2}} \\
%   \langmin\parens{\regex} = \regex_1 \cdot \regex_2
%     &\implies
%       \premucount\parens{\reglang\parens{\regex}} =
%         \premucount\parens{\reglang\parens{\regex_1}} \cdot
%         \premucount\parens{\reglang\parens{\regex_2}} \\
%   \langmin\parens{\regex} = \regex_1 ^\ast
%     &\implies
%       \premucount\parens{\reglang\parens{\regex}}
%         = \begin{cases}
%             \infty & \quad \premucount\parens{\regex_1} > 0 \\
%             0 & \quad \text{otherwise}
%           \end{cases}
% \end{align*}
% 
% Observe that almost by definition (and a combinatorial argument),
% \(\premucount\parens{\reglang\parens{\regex}}\) counts the size of
% the language corresponding to regular expression \(\regex\).
% 
% We now demonstrate that \(\premucount\) is indeed a pre-measure.
% 
% \begin{theorem}
%   The function \(\premucount\) defines a pre-measure.
% \end{theorem}
% \begin{proof}
%   Consider a countable alphabet \(\alphabet\) and the set of all
%   regular expressions \(\mathcal{E}\).
% 
%   First observe that the empty language \(\emptyset\)
%   is regular,
%   and is generated by the empty string \(\empstr \in \mathcal{E}\).
%   For this we have that \(\premucount\parens{\emptyset} = 0\),
%   thereby satisfying the requirement that empty sets map to zero.
%   
%   Now, consider two regular languages
%   \(\reglang\parens{\regex_1}\) and \(\reglang\parens{\regex_2}\)
%   that are disjoint.
%   Recall that the semantics of \(+\) means that:
%   \begin{align*}
%     \reglang\parens{\regex_1 + \regex_2} =
%       \reglang\parens{\regex_1} \cup \reglang\parens{\regex_2}
%   \end{align*}
%   Furthermore, because \(\reglang\parens{\regex_1}\) and
%   \(\reglang\parens{\regex_2}\) are disjoint, this means that
%   \(\langmin\parens{\regex_1} + \langmin\parens{\regex_2}\) is in
%   the desired canonical form.
%   Hence, we expand this as follows:
%   \begin{align*}
%     \premucount
%       \parens{\reglang\parens{\regex_1} \cup \reglang\parens{\regex_2}}
%       = \premucount\parens{\reglang\parens{\regex_1 + \regex_2}}
%       = \premucount\parens{\reglang\parens{\regex_1}} +
%         \premucount\parens{\reglang\parens{\regex_2}}
%   \end{align*}
%   This satisfies the additivity rule for pre-measures.
% \end{proof}



