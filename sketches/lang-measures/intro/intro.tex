\section{Introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Regular Languages}

\begin{definition}[Alphabet]
  An alphabet \(\alphabet\) is a countable set of distinct
  \textit{characters}.
  \hfill\(\square\)
\end{definition}

\begin{example}
  The English alphabet of 26 (lower-case) characters forms an alphabet
  where we have
  \(\alphabet = \braces{a, b, \ldots, y, z}\).
  \hfill\(\square\)
\end{example}

\begin{definition}[Language]
  Let \(\alphabet^\ast\) be the set of all (possibly countably infinite)
  strings of a language.
  A language \(\lang\) is a subset \(\lang \subseteq \alphabet^\ast\).
  Denote the set of languages as \(\langs\).
  \hfill\(\square\)
\end{definition}

\begin{definition}[Regular Language]
  A regular language \(\reglang\) is a language that can be
  \textit{recognized} by a \textit{deterministic finite automata} (DFA).
  In other words, there exists a DFA \(A_{\reglang}\) such that:
  \begin{align*}
    \forall s \in \reglang \st A_{\reglang}\parens{s} = 1
  \end{align*}
  Denote the set of regular languages as \(\reglangs\).
  \hfill\(\square\)
\end{definition}

First, all regular languages are languages: \(\reglangs \subseteq \langs\).

It is well known that DFAs and regular languages form a bijection.
Furthermore, all DFAs can be reduced to a canonical form.
If a DFA \(A_{\reglang}\) recognizes a regular language \(\reglang\),
write \(\langmin\parens{A_{\reglang}}\) to be a canonical DFA.

DFA's can also be described via \textit{regular expressions}.

\begin{definition}[Regular Expression]
  A regular expression \(\regex\)
  is a finite string over an alphabet \(\alphabet\)
  defined inductively, such that:
  \begin{itemize}
    \item
      The empty string \(\empstr\) is a regular expression

    \item
      If \(\regex_1\) and \(\regex_2\) are regular expressions,
      then \(\regex_1 + \regex_2\) is a regular expression

    \item
      If \(\regex_1\) and \(\regex_2\) are regular expressions,
      then \(\regex_1 \cdot \regex_2\) is a regular expression

    \item
      If \(\regex\) is a regular expression,
      then \(\regex^\ast\) is a regular expression
  \end{itemize}
  If \(\regex\) is a regular expression, denote the 
  regular language generated by it as \(\reglang\parens{\regex}\).
  We implicitly assume a common alphabet,
  and denote the set of regular expression as \(\regexes\).
  \hfill\(\square\)
\end{definition}

Regular expressions textually represent DFAs, and can be thought of
as rules for how to generate a \textit{regular language}.
There should be a theorem somewhere about a bijection between
regular expressions and DFAs.
Here, the \(+\) operator can be thought of as string choice,
the \(\cdot\) operator can be thought of as string concatenation,
and the \(\ast\) operator (Kleene star) denotes zero or more occurrences
of a regular expression.
We often elide \(\cdot\) when the context is clear.
The \(\cdot\) syntactically
binds tighter than \(+\), meaning that ``multiplication''
distributes over ``addition''.

\begin{example}
  Consider the alphabet \(\alphabet = \braces{a, b, c, d}\),
  with regular expression \(\regex = ab + c + d^\ast\).
  Then the regular language \(\reglang\parens{\regex}\) is the set:
  \begin{align*}
    \reglang\parens{\regex} =
      \braces{ab, c, \empstr, d, dd, ddd, \ldots}
  \end{align*}
  \hfill\(\square\)
\end{example}

Finite language union, intersection, and complement
with respect to a common alphabet
is also well-defined for regular languages.

We can likewise also define a canonical representation for a
regular expression \(\langmin\parens{\regex}\) with the following features:
\begin{align*}
  \langmin\parens{a} = a
    &\qquad \langmin\parens{\empstr} = \empstr
    \qquad \langmin\parens{\regex^\ast} = \langmin\parens{\regex}^\ast \\
  \langmin\parens{\regex}
      = \langmin\parens{\regex_1} + \langmin\parens{\regex_2}
    &\iff \reglang\parens{\regex_1} \cap \reglang\parens{\regex_2}
      = \emptyset \\
  \langmin\parens{\regex}
      = \langmin\parens{\regex_1} \cdot \langmin\parens{\regex_2}
    &\iff \reglang\parens{\regex_1} \cap \reglang\parens{\regex_2} = \emptyset
\end{align*}
We take the existence of this magical \(\langmin\) function for granted,
because the properties that it gives for regular expression
reduction are invaluable for later.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Measure Theory}
Some talk about measure theory goes here


