\section{Introduction}

\subsection{Notation}

Let \(\Sigma\) denote a non-empty, countable alphabet.
Unless otherwise specified, assume \(\abs{\Sigma} < \infty\).
Write \(\varepsilon\) to mean the empty string.

Let \(\Sigma^\star\) be the set of all finite strings from \(\Sigma\).
Write strings as \(w\) or \(s\), whichever happens to be more convenient.

Let \(L\) denote a language, implicitly over \(\Sigma\).
In other words, \(L \subseteq \Sigma^\star\).

We treat the empty language \(\emptyset\) as distinct from
the language with a single empty string \(\braces{\varepsilon}\).

Let \(\mcal{L}\) be a family of languages.

Write deterministic finite automatons shorthand as DFA,
and non-deterministic finite automataons shorthand as NFA.

Write regular expressions shorthand as regex.

If \(X\) is a set, then \(\powset{X}\) is the powerset of \(X\).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Representation of Regular Languages}
There are several ways to represent regular languages,
many of which can be fonud in literature~\cite{savage1998models}.
We work with whatever is convenient for the problem at hand.
For a regular language \(L\) over an alphabet \(\Sigma\),
there are a few notable ones:

\begin{enumerate}
  \item[(1)]
    \textbf{Sets}:
    sometimes if the language is finite or has a simple structure,
    a complete set presentation may be convenient.

  \item[(2)]
    \textbf{Regular expressions}:
    compact representation,
    also commonly used in practice when trying to do string matching.

  \item[(3)]
    \textbf{Finite state machines}:
    Savage~\cite{savage1998models} gives a fairly standard representation.

    \begin{definition}[DFA]
      A DFA \(A\) is a five-tuple \(A = \parens{\Sigma, Q, \delta, q_0, F}\),
      where \(\Sigma\) is the alphabet, \(Q\) is the finite set of states,
      \(\type{\delta}{Q \times \Sigma}{Q}\) is the transition function,
      \(q_0\) is the initial state, and \(F\) is the set of final states.
    \end{definition}

    For convenience, we might also write \(q_0\) as \(q_1\),
    especially when talking about matrix indices.
    We'll try to remember to make note of when this rewriting is done.

    \begin{definition}[NFA]
      A NFA \(A\) is identically defined except for the
      transition function, which is now
      \(\type{\delta}{Q \times \Sigma}{\powset{Q}}\).
      Each transition non-deterministically picks one state from the set.
    \end{definition}

  \item[(4)]
    \textbf{Matrices}:
    transition matrices can be constructed from both DFAs and NFAs.
    First, take \(Q = \braces{q_1, q_2, \ldots, q_n}\).
    There are two primary possibilities:

    \begin{enumerate}
      \item[(a)]
        A matrix \(M_A\) corresponding to an automata \(A\),
        with \(q_1\) the initial state.
        Write \(+\braces{\ldots}\) do denote
        the summation regular expression over a set.
        We construct the matrix as follows:
        \begin{align*}
          M_{A, i, j} =
            + 
        \end{align*}


      \item[(b)]
    \end{enumerate}

\end{enumerate}


