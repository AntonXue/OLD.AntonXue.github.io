\subsection{Counting}
How many unique strings of length \(k\) does an automata have?
The question is relatively straightforward for a DFA,
and slightly more complicated for a NFA.

\begin{theorem}
  There exists a polynomial-time algorithm that counts the number of strings
  accepted by a DFA.
\end{theorem}
\begin{proof}
  Consider the matrix \(M\) representation of a
  DFA \(A = \parens{\Sigma, Q, \delta, q_1, F}\),
  which we claim can be conjured in polynomial time.
  Roughly, the sketch is that we can enumerate each element
  of the transition \(\delta\) and iteratively populate our matrix \(M\).

  We define \(M^\prime\)
  where \(M^\prime _{i, j} = 1_{M_{i, j} \neq \emptyset}\).
  In other words, \(M^\prime\) is the adjacency
  matrix corresponding to the directed graph described by \(A\) and \(M\).

  Let \(u\) be the vector where each element is such that
  \(u_i = 1_{q_i \in F}\), then:
  \begin{align*}
    \parens{1, 0, 0, \ldots} \parens{M^\prime}^k u
  \end{align*}
  Will count the number of strings of length \(k\).
  The algorithm runs in time polynomial to \(k\) the length
  and \(n = \abs{Q}\) the number of states,
  because matrix multiplication is polynomial in complexity.
\end{proof}

However, counting the number of strings of length \(k\) is known to be
\(\class{\#P}\)~\cite{acmsiam-kannan1995counting},
and exponential-time algorithms are known:
just reduce the NFA to a DFA and run the solution above.
Indeed, this is not very satisfying, but at least it's something.

\subsection{Approximate Counting}
If counting is hard, then perhaps approximate counting is easier?
Indeed, this may be the step towards fast comparison of regular languages.
To do this,
we attempt to adapt work by Kannan~\cite{acmsiam-kannan1995counting},
which we have cited quite a few times now.

Kannan's construction presents a few ``proofs left to the reader'',
which we complete here.
However, we first present a few definitions that are used throughout
the paper.

\begin{definition}[\(g\parens{n}\)-randomized approximation scheme]
  A \(g\parens{n}\)-ras for a non-negative real-valued function
  \(f\) is a probabilistic algorithm which,
  on input \(x\) and \(\varepsilon > 0\) and \(\delta < 1\),
  computes \(\widetilde{f}\parens{x}\) where:
  \begin{align*}
    1 - \delta \leq
    \Pr\brackets{
      f\parens{x} \parens{1 + \varepsilon}^{-1}
        \leq \widetilde{f}\parens{x}
        \leq f\parens{x} \parens{1 + \varepsilon}}
  \end{align*}
  Further, the algorithm runs in expected time \(O\parens{g\parens{n}}\)
  where:
  \begin{align*}
    n = \max\braces{\abs{x}, \varepsilon^{-1}, \log\parens{\delta^-1}}
  \end{align*}
\end{definition}

In other words, this randomized approximation scheme is pretty tight.

\begin{definition}[\(g\parens{n}\)-almost uniform generator]
  Let \(R\) be a polynomial-time computable binary relation.
  For any \(x\), let
  \begin{align*}
    \phi\parens{x} = \braces{y \st \parens{x, y} \in R}
  \end{align*}
  A \(g\parens{n}\)-almost uniform generator for the relation
  \(R\) is a probabilistic algorithm \(A\),
  which, on input \(x\), \(\varepsilon > 0\),
  outputs some \(y \in \phi\parens{x}\) such that:
  \begin{align*}
    \abs{\phi\parens{x}}^{-1} \parens{1 + \varepsilon}^{-1}
      \leq \Pr\brackets{A\parens{x, \varepsilon} = y}
      \leq \abs{\phi\parens{x}}^{-1} \parens{1 + \varepsilon}
  \end{align*}
  Also, \(A\) runs in time \(O\parens{g\parens{n}}\)
  where:
  \begin{align*}
    n = \max\braces{\abs{x}, \log\parens{\varepsilon^{-1}}}
  \end{align*}
\end{definition}

\begin{definition}[\(m\)-level NFA]
  An \(m\)-level NFA is an NFA in which the states can be
  partitioned into \(m + 1\) levels with the following properties:
  \begin{enumerate}
    \item[(1)]
      There is exactly one state at level \(0\) and it is the start state.

    \item[(2)]
      There is exactly one state at level \(m\) and it is the accept state.

    \item[(3)]
      All transitions are from a node in level \(i\) to a node in
      level \(i + 1\) for \(i \in \braces{0, \ldots, m - 1}\).

    \item[(4)]
      For any state, \(p\),
      the accept state is reachable from \(p\),
      and \(p\) is reachable from the start state
      (fully connected automata).
  \end{enumerate}
\end{definition}

Kannan further poses the following lemma as an exercise to the reader,
which we also prove:

\begin{lemma}
  For any NFA, \(M\), and integer \(m\),
  there exists an NFA \(M^\prime\) such that \(M^\prime\)
  is an \(m\)-level NFA with no \(\epsilon\)-transitions,
  a binary alphabet, and such that
  \(\abs{L\parens{M^\prime}} = \abs{L\parens{M} \cap \Sigma^m}\).
  Further, the size of \(M^\prime\) is polynomial in size of \(M\) and \(m\).
\end{lemma}
\begin{proof}
  Given an NFA \(M_1\), it is well-known that there exist
  a polynomial-time and polynomial-space reduction to an equivalent
  NFA \(M_2\) without \(\epsilon\)-transitions.

  As \(M_2\) is presumed to be defined over some alphabet \(\Sigma\),
  we now need to reduce this to an equivalent NFA over a binary alphabet
  \(\Sigma_2\).
  To do this, recall from standard results in complexity that we need
  \(\ceil{\log\parens{\abs{\Sigma}}}\) bits to represent every element
  of \(\Sigma\).
  Hence, in order to make an \(\epsilon\)-transition-free and
  binary alphabet NFA,
  we may augment every transition edge of \(M_2\)
  by a sequence of transitions of length
  \(\ceil{\log\parens{\abs{\Sigma}}}\) that now uses the binary
  alphabet \(\Sigma_2\) instead of \(\Sigma\).
  Take \(m^\prime = m \ceil{\log\parens{\abs{\Sigma}}}\).
  This produced \(M_3\), which lacks \(\varepsilon\)-transitions
  and is over a binary alphabet \(\Sigma_2\).

  To convert the NFA \(M_3\) into a
  \(m^\prime\)-level NFA,
  we do the following.
  First, let \(Q\) be the set of states of \(M_3\).
  We create \(m^\prime\) copies of \(Q\), and write them as
  \(Q_0, Q_1, \ldots, Q_{m^\prime - 1}\).
  These serve to eventually form the first \(m^\prime\)-layers out of the
  \(m^\prime + 1\) for an \(m^\prime\)-level NFA.
  For each set of states \(Q_i\), with
  \(i \in \braces{0, \ldots, m^\prime - 2}\)
  as follows: if there exists a one-step transition from some \(q_a\) to
  \(q_b\) on character \(a \in \Sigma_2\) within \(M_3\),
  then we connect \(q_a \in Q_i\) and \(q_b \in Q_{i + 1}\) using
  letter \(a\).
  We add a final layer consisting of just one state \(q_F\),
  and connect all the final states of \(Q_{m^\prime - 1}\) to
  \(q_F\) using the technique just described.
  This creates \(M_4\), which has \(m^\prime + 1\) layers,
  the last of which has a single final state.

  In order to make \(M_4\) into an \(m^\prime\)-level NFA
  (which has \(m^\prime + 1\) layers),
  we need another step of transformation.
  Take \(q_0 \in Q\) to be the start state of \(M_3\).
  Then, in the first layer, mark \(q_0\) as the start state.
  Now take the sub-graph of \(M_4\) that is reachable from \(q_0\)
  in the first layer,
  and this is the desired \(m^\prime\)-level automaton \(M_5\).

  Because the start state \(q_0\) is unique, it is clear that
  the first layer only has a single state.
  Furthermore, the last layer also has a single state \(q_F\), which
  we added by construction earlier.
  In addition, all transition edges by construction flow from
  layer \(i\) to the next layer \(i + 1\).

  Because we have taken the parts reachable from the initial state \(q_0\),
  we guarantee reachability.
  It may be the case that the final state \(q_F\) is not reachable from
  \(q_0\), in which case this is fine,
  and the \(m^\prime\)-level NFA cannot be constructed anyways,
  because it implies that no strings of length \(m\) exists in
  the language.
  Further note that \(m^\prime\) is polynomial in complexity to \(m\).
  Hence, \(M_5\) is the desired \(m^\prime\)-level NFA.

\end{proof}



