\subsection{An Algorithm For Measuring}

We are now ready to present a
quasi-polynomial algorithm for calculating the
measure of a language's strings up to some length \(N\),
which we describe as follows:

\begin{enumerate}
  \item[(1)]
    Take as input a NFA \(M\) that represents language \(L\),
    some positive integer \(N\), and error bounds \(\varepsilon > 0\)
    and confidence \(\delta < 1\).

  \item[(2)]

    Let \(A\) be the algorithm specified in
    Kannan's work~\cite{acmsiam-kannan1995counting}
    that takes as input a \(m_A\)-level NFA,
    error tolerance \(\varepsilon_A\),
    and confidence \(\delta_A\).

  \item[(3)]
    At each stage, let \(M_m\) be the \(m\)-level NFA of \(M\), and
    calculate the following:
    \begin{align*}
      v =
      \sum_{k = 0}^{N}
        \frac{A\parens{M_k, \varepsilon / N, \delta / N}}{\abs{\Sigma^k}}
          \eta \parens{k}
    \end{align*}

  \item[(4)]
    Return \(v\) as an estimate for the measure up to
    strings of length \(N\).
\end{enumerate}


\begin{theorem}
  The algorithm runs in quasi-polynomial time with respect to
  \(N\), \(\abs{M}\), \(\varepsilon\), and \(\delta\).
\end{theorem}
\begin{proof}
  It suffices to show that each iteration of the sum is
  quasi-polynomial in complexity.
  Because only \(N\) iterations occur,
  if each iteration is quasi-polynomial,
  then the entire sum is also quasi-polynomial.

  We have shown before that a polynomial-time reduction from
  \(M\) to \(M_k\) is possible for each \(k\).
  Furthermore, this is directly fed into the
  quasi-polynomial time algorithm \(A\).
  We implicitly assume \(\eta\) to be polynomial time in complexity.
  Therefore, each iteration is quasi-polynomial time in complexity.

  Together, this means that the entire algorithm is
  quasi-polynomial time in complexity.
\end{proof}

