\documentclass[12pt]{article}

% Packages
\usepackage[margin=5em]{geometry} % 1 cm = 2.84528 em
\usepackage[backend=bibtex]{biblatex}
\bibliography{sources}
% \nocite{*}

\usepackage{lipsum}

% Paragraphs
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

% Includes
\input{axlib.tex}


\let\pred\undefined
\newcommand{\pred}{\mathbf{pred}}

\let\ancestors\undefined
\newcommand{\ancestors}{\mathbf{ancestors}}

\let\depth\undefined
\newcommand{\depth}{\mathbf{depth}}

\let\next\undefined
\newcommand{\next}{\mathbf{next}}

% Author
\title{Synchronization Graphs}
\author{R-KFC-A}
\date{\today}
\date{}

% Document
\begin{document}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

In this we examine parsing streams of tagged vertices
into a canonical \textit{synchronization graph}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background}

\begin{definition}[Dependency Relation]
  A dependency relation \(D \subseteq \Sigma \times \Sigma\)
  is a \textit{symmetric} and \textit{reflexive}
  relation on \(\Sigma\).
\end{definition}

Likewise an independence relation of \(D\) can be defined as
the relative complement
\(I = (\Sigma \times \Sigma) \setminus D\).

Dependency relations are a general way of talking about
\textit{equivalence} relations between two streams of data
\(S_1, S_2 \in \Sigma^\star\),
where we say \(S_1 \equiv_D S_2\) if \(S_2\) can be reached from \(S_1\)
(and vice versa) by appling permutations based on
the independence relation \(I\).

\begin{definition}[Tree Dependence Relation]
  A tree dependence relation \(T \subseteq \Sigma \times \Sigma\)
  is a dependence relation such that
  \((\Sigma, T)\) induces a graph with vertices
  \(\Sigma\) and edges \(T\)
  that forms a tree with a distinguished root \(\sigma_{\top}\).
  Furthermore, if \(\sigma_1 \in \ancestors(\sigma_2)\), then
  \(\sigma_1 T \sigma_2\).
\end{definition}

There are a few functions we can define on \(T\).
  Define the predecessor function with respect to this rooting,
  with \(\pred(\sigma_\top) = \sigma_\top\);
  recursively define the depth function
  \(\depth(\sigma_\top) = 0\) and
  \(\depth(\sigma) = 1 + \depth(\pred(\sigma))\).

We define a \textit{synchronization graph},
which is intended to model data streams that
(1) are equipped with a dependence relationship
and (2) have ``synchronizing''
(also: visibly pushdown / parallel / end-marker'd) behavior.

\begin{definition}[Synchronization Graph]
  A synchronization graph \(G\) is a directed acyclic graph
  with a unique \textit{source} (top) vertex \(\vee G\)
  and a unique \textit{sink} (bot) vertex \(\wedge G\).
  Recursively define \(G\) as follows:
  \begin{enumerate}
    \item[i.] (Base Case):
      A single vertex is a syncrhonization graph.

    \item[ii.] (Sequential Concatenation):
      If \(G_1\) and \(G_2\) are synchronization graphs,
      then \(G = G_1 \cdot u \cdot G_2\) is also a synchronization graph
      for a new vertex \(u\), where
      \begin{align*}
        (\wedge G_1, u), (u, \vee G_2) \in G,
        \qquad \vee G = \vee G_1,
        \qquad \wedge G = \wedge G_2
      \end{align*}


    \item[iii.] (Parallel Union):
      If \(G_1\) and \(G_2\) are synchronization graphs,
      then \(G = u [ G_1 || G_2 ] v\) is also a synchronization graph
      for new vertices \(u, v\) where
      \begin{align*}
        (u, \vee G_1), (u, \vee G_2),
        (\wedge G_1, v), (\wedge G_2, v) \in G,
          \qquad \vee G = u,
          \qquad \wedge G = v
      \end{align*}

  \end{enumerate}
\end{definition}

Note that synchronization graphs induce a natural partial order:
\(u \preceq v\) if either (1) \(u = v\) or (2) \(v\) is reachable from \(u\).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{A Parsing Problem}
In this problem setting, we are given:
\begin{enumerate}
  \item[i.] A tree dependency relation \(T\) and its alphabet \(\Sigma\)

  \item[ii.]
    A sequence of vertices \(v_1, v_2, \ldots\)
    each labeled with an element of \(\Sigma\):
    that is, \(\tau(v_i) \in \Sigma\) for all \(i\).
    This sequence is a linearization of a stream satisfying \(T\).

\end{enumerate}

The task is to generate a \textit{canonical} synchronization graph.


\section{A Basic Algorithm}
A basic algorithm we have is to iteratively grow \(G\).
Let \(\next()\) return the next vertex in the stream;
iteratively keeping track of a \textit{frontier} of leaf vertices \(L\),
every new vertex \(v\) has one of three possibilities:
\begin{enumerate}
  \item[1.]
    It depends on exactly one \(l \in L\).

  \item[2.]
    It depends on more than one \(M \subseteq L\).
    Furthermore, \(\depth(\tau(m)) < \depth(\tau(v))\)
    for all \(m \in M\).
    In this case \(v\) acts as a common ``synchronization point''
    for \(M\).

  \item[3.]
    \(v\) is independent with all of \(L\),
    in which case the \textit{most recent depenency} of \(v\),
    written
    \(u^\star = \bigvee \{ u \in G : \tau (u) T \tau (v)\} \)
    is found and \(v\) appends to this.
  
\end{enumerate}


\begin{center}
\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgorithmName{Parsing Linearized Stream}
  % \KwData{some data}
  \KwResult{A fully constructed synchronization graph \(G\)}

  \textbf{Precondition:} data stream \(S\) begins and ends with a
  vertex labeled \(\sigma_\top\)\;

  Initialize \(L \rightarrow \emptyset\)\;

  Initialize \((V, E) \leftarrow (\emptyset, \emptyset)\).

  Pop the first \(v \leftarrow \next()\) and set \(V \leftarrow \{v\}\).

  \While{\(v \leftarrow \next()\) succeeds}{
    Let \(M = \{l \in L : \tau(l) T \tau (v)\}\)
    \(V \leftarrow V \cup \{v\}\)\;

    \uIf{\(M = \{l\}\)}{
      \(E \leftarrow E \cup \{(l, v)\}\)\;
      \(L \leftarrow (L \setminus \{l\}) \cup \{v\}\)\;
    }
    \uElseIf{\(\abs{M} > 1\)}{
      \(E \leftarrow E \cup \{(m, v) : m \in M\}\)\;
      \(L \leftarrow (L \setminus M) \cup \{v\}\)
    }
    \Else{
      \(u^\star = \bigvee \{u \in V : \tau(u) T \tau (v)\}\)\;
      \(E \leftarrow E \cup \{(u^\star, v)\}\)\;
      \(L \leftarrow L \cup \{v\}\)
    }
  }
  \Return{\(G = (V,E)\)}

  \caption{Algorithm}
  % \caption{How to write algorithms}
  \label{alg:parse-linearized}
\end{algorithm}
\end{center}



\begin{lemma}
  Two streams that are \(T\)-equivalent have the same decomposition
  under Algorithm~\ref{alg:parse-linearized}.
\end{lemma}
\begin{proof}
  \red{TODO}
\end{proof}


\begin{lemma}
  At each iteration of the algorithm,
  there is at most one \(l \in L\) such that
  \(\depth(\tau(l)) = \depth(\tau(v))\)
  and \(\tau(l) T \tau(v)\).
\end{lemma}
\begin{proof}
  \red{TODO: something about induction}
\end{proof}

\begin{lemma}
  At the each iteration, \((V, E)\) respects \(T\).
\end{lemma}
\begin{proof}
  \red{TODO: Also something about induction}
\end{proof}

\printbibliography

\end{document}

