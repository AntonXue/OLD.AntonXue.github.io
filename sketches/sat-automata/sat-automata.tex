\documentclass[12pt]{article}

% Packages
\usepackage[margin=5em]{geometry} % 1 cm = 2.84528 em
\usepackage[backend=bibtex]{biblatex}
\bibliography{sources}
% \nocite{*}

\usepackage{lipsum}

% Paragraphs
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

% Includes
\input{antonxue-lib.tex}
% \input{lang-lib.tex}


% Author
\title{Separating Strings with Automata and SAT}
% \author{Anton Xue}
% \date{\today}
\date{}

% Document
\begin{document}
\maketitle

\section{Introduction}
In this sketch we study
how to use SAT to construct a non-deterministic finite automata (NFA)
that separates two finite sets of strings.
This yields a decision procedure for calculating
the metric distance between two regular sets with respect to the
(inverse) automata size metric.


\section{Preliminaries}
An alphabet \(\Sigma\) is a finite set of unique symbols.
Let \(\Sigma^\star\) denote the set of all finite strings consisting of
letters from \(\Sigma\).
A language \(\mcal{L} \subseteq \Sigma^\star\) is then
a countable set of strings of \(\Sigma\).
Often \(\Sigma\) is implicitly assumed.

A non-deterministic finite automata (NFA) \(\mcal{A}\) is represented
as a tuple
\(\mcal{A} = \parens{\Sigma, Q, \Delta, S, F}\)
where \(\Sigma\) is a finite alphabet,
\(Q\) is a finite set of states,
\(\type{\Delta}{\parens{Q \times \Sigma}}{\powset{Q}}\)
is the transition function,
\(S \subseteq Q\) is the inital states,
and \(F \subseteq Q\) is a set of final states.

For some string \(w\) we say that \(\mcal{A}\) accepts \(w\)
if there exists a sequence of transitions on which \(\mcal{A}\) ends
in a final state when reading \(w\).
We abuse notation and say
that \(\mcal{A}\) accepts \(w\) if \(\mcal{A}\parens{w} = 1\).
Similarly, we say \(\mcal{A}\parens{w} = 0\) if \(\mcal{A}\) rejects \(w\).

Let \(w_i\) denote the \(i\)th letter of the string \(w\),
and \(\varepsilon\) be the empty string.



\section{Separating Sets}

The question that this sketch attempts to answer can be formalized as follows:

\begin{question}
Given a positive set \(P \subseteq \Sigma^\star\)
and negative set \(N \subseteq \Sigma^\star\)
with \(P\) and \(N\) disjoint,
does there eixst an NFA
\(\mcal{A} = \parens{\Sigma, Q, \Delta, S, F}\)
with \(\abs{Q} = n\)
such that for all \(u \in P\) in the positive set \(\mcal{A}\parens{u} = 1\),
but for all \(v \in N\) in the negative set \(\mcal{A}\parens{v} = 0\).
\end{question}

We achieve this by constructing a boolean satisfiability formula
that encodes \(P\) and \(N\),
and is satisfiable if and only if such \(\mcal{A}\) exists.
There are several high-level insights that we leverage:
\begin{enumerate}
  \item[(1)]
    NFAs can be represented as directed multi-edge graphs
    where each edge is labeled by one letter from \(\Sigma\).
    Self-loops are permitted here.
    In other words, let \(e_{i, j, \sigma}\) be an indicator
    variable encodes the indicator of a transition from state \(q_i\)
    to state \(q_j\) on the letter \(\sigma\).

  \item[(2)]
    For each \(u \in P\),
    we can create a formula that forces a sequence of edge walks
    resulting in a final state in \(\mcal{A}\).
    Similarly for each \(v \in N\) we can encode a sequence that will force
    a rejection of \(v\) in \(\mcal{A}\).

\end{enumerate}

We first construct a formula that will force \(\mcal{A}\) to accept
a word \(w\) if and only if the formula is satisfied.
Let \(y_{i, t}^w\) denote be an indicator variable
to show that \(\mcal{A}\) is at state \(q_i\) at time \(t\),
with \(1 \leq i \leq n\) and \(1 \leq t \leq \abs{w} + 1\).
Note that since each letter of \(w\) acts as a transition,
the automata will occupy \(\abs{w} + 1\) possibly repeated
states during its accepting run.
Then:
\begin{align*}
  \rho_w \equiv
    \bigwedge_{1 \leq t \leq \abs{w} + 1}
      \brackets{\bigwedge_{1 \leq i, j \leq n}
        \neg \parens{y_{i, t} ^w \land y_{j, t} ^w}}
\end{align*}
Forces the automata to be in only one state at any given time \(t\)
while reading \(w\).
To accompany this, let \(e_{i, j, \sigma}\) to denote
that \(\mcal{A}\) has a transition edge from \(q_i\) to \(q_j\)
on letter \(\sigma\).
Similarly:
\begin{align*}
  \pi_w \equiv
    \bigwedge_{1 \leq t \leq \abs{w}}
      \brackets{\bigvee_{1 \leq i, j \leq n}
      \parens{y_{i, t} ^w \land y_{j, t + 1} ^w \land e_{i, j, w_t}}}
\end{align*}
Additionally, we can force boundary conditions to ensure that \(\mcal{A}\)
begins reading \(w\) on a starting state and ends on an accepting state:
\begin{align*}
  \gamma_{w} \equiv
    \brackets{\bigvee_{1 \leq i, j \leq n}
        \parens{e_{i, j, w_{1}} \land s_i}}
      \lor
    \brackets{\bigvee_{1 \leq i, j \leq n}
        \parens{e_{i, j, w_{\abs{w}} \land f_i}}}
\end{align*}
Then finally we set:
\begin{align*}
  \varphi_{w} \equiv \rho_w \land \pi_w \land \gamma_w
\end{align*}
Then \(\mcal{A}\) will only accept \(w\) if and only if \(\varphi_w\)
is satisfiable.


\red{AAAAAAAAAAAAAAAAA}


For any \(w \in \Sigma^\star\), consider the following encoding:
\begin{align*}
  \pi_w \equiv
    \bigwedge_{1 \leq t < \abs{w} + 1}
      \parens{\bigvee_{i \neq j \neq k}
        e_{i, j, w_t} \land e_{j, k, w_{t + 1}}}
\end{align*}
This forces the existence of a path on \(\mcal{A}\) for \(w\).
The number of states in the walk of an accept will be \(\abs{w} + 1\),
since each letter in \(w\) acts as transition between states.
Additionally, to force \(w\) to stop on a final state,
we may either have every state be a final state,
or just set the following formula:
\begin{align*}
  \varphi_w \equiv
    \brackets{\bigwedge_{i \neq j} \parens{e_{i, j, w_{1}} \implies s_i}}
      \land
    \brackets{\bigwedge_{i \neq j} \parens{e_{i, j, w_{\abs{w}}} \implies f_j}}
\end{align*}
Essentially, this forces each \(w\) to begin processing on an initial state
as indicated by \(s_i\), and end on a final state as indicated by \(f_j\).
Thus, the conjunction \(\pi_w \land \varphi_w\) will be true if and
only if \(\mcal{A}\) accepts \(w\).
Hence, the satisfaction of
its negation will then force \(\mcal{A}\) to reject \(w\).
We leverage this in order to define
over \(P\) and \(N\):
\begin{align*}
  \Phi_{P, N} =
    \brackets{\bigwedge_{u \in P} \parens{\pi_u \land \varphi_u}}
      \land
    \brackets{\bigwedge_{v \in N} \neg\parens{\pi_v \land \varphi_v}}
\end{align*}
Thus, \(\Phi_{P, N}\) defines a formula that will make
\(\mcal{A}\) to accept \(P\) and reject \(N\).

The variables of the \(\Phi_{P, N}\)
are the indicators for edges of form \(e_{i, j, \sigma}\) and
final states of form \(f_j\).
Suppose that \(\Sigma\) is known.
If \(\Phi_{P, N}\) is satisfiable,
then \(\mcal{A} = \parens{\Sigma, Q, \Delta, S, F}\) can be extracted as:
\begin{align*}
  Q &= \braces{q_1, \ldots, q_n} \\
  \Delta &= \braces{\parens{\parens{q_i, \sigma}, q_j} \st e_{i, j, \sigma} = \top} \\
  S &= \braces{q_i \st s_i = \top} \\
  F &= \braces{q_j \st f_j = \top} \\
\end{align*}
Note that \(\Delta\) is slightly overloaded.



\end{document}


