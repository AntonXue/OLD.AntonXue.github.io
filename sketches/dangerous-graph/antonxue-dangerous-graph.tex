\documentclass[12pt]{article}

% Packages
\usepackage[margin=6em]{geometry} % 1 cm = 2.84528 em
\usepackage[colorlinks=true,linkcolor=red,urlcolor=blue]{hyperref}
\usepackage{tikz}
\usetikzlibrary{automata}
\usepackage[backend=bibtex]{biblatex}
\bibliography{sources}
\nocite{*}

\usepackage{lipsum}

% Paragraphs
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

% Includes
\input{antonxue-lib}


\let\company\undefined
\newcommand{\company}{\textbf{Big Tech Company}}

\let\Android\undefined
\newcommand{\android}{Android}

\let\state\undefined
\newcommand{\state}{\ensuremath{\sigma}}

\let\var\undefined
\newcommand{\var}{\ensuremath{x}}

\let\domval\undefined
\newcommand{\domval}{\ensuremath{\mathcal{A}}}

\let\formula\undefined
\newcommand{\form}{\ensuremath{\varphi}}

\let\domform\undefined
\newcommand{\domform}{\ensuremath{\mathcal{F}}}

% Author
\title{The Dangerous Graph}
\author{Anton Xue}
% \date{\today}
\date{}

% Document
\begin{document}
\maketitle

\subsection{Real-World Applications?}

A friend working at \company{} told to me about a problem
they were working on:
how do we automatically detect crashing errors in \android{} applications?

Users interacts with \android{} applications by touching
the phone's user interface (UI).
Touching the UI in specific ways alters the internal state of the application.
The UI is specified by XML files that (each?) represent a
different display layout.
When specific touches are performed, different displays may be shown.
These display transitions are conditional on the internal state of the
application and the current active display.

We then ask:
\textbf{what sequence of actions will cause the application to crash?}


\subsection{Defining the Problem}
From a high-level perspective, the problem is not well-defined in part
because we have not discussed the level of access we have to the
application under testing.
Are we given the source code?
Can we monitor internal application state and variables during execution?
Or are we given just the phone and told to play with it?

If we have access to the source code, we may apply techniques such as
backwards symbolic execution~\cite{baldoni-backwards} or
slicing~\cite{weiser-slicing}.

If we may monitor application state during execution through some debugger
or trace dumper, then short of decompilation, we may try techniques such
as randomized testing or somehow approximating behavior.

If we are given just a phone, then we throw it against a wall.

The first condition presented, with complete source code access, is of
course, the most favorable.
It is also the biggest headache because all the techniques listed are
a pain to implement.

We opt for the second.

\subsection{Modeling the Problem}
\begin{definition}[Tail and Head Set]
For a directed multigraph $G = \parens{V, E}$,
where each edge has form $e = \parens{u, v} \in E$ with tail $u$ and head $v$,
we define the \textit{tail set} $T_u$ and \textit{head set} $H_v$:
\begin{align*}
  T_u &= \setcomp{\parens{u, v}}{\exists v \st \parens{u, v} \in E} \\
  H_v &= \setcomp{\parens{u, v}}{\exists u \st \parens{u, v} \in E}
\end{align*}
$\square$
\end{definition}

This allows us to abbreviate some notation when reasoning about multigraphs.

\begin{definition}[Application Graph]
An \textit{application graph} is a directed multigraph $G = \parens{V, E}$,
where each edge is labeled with a formula $e_{\form}$ in some logical
theory $\domform$ such that:
\begin{enumerate}
  \item[(1)]
    The formula associated with each edge in a tail set is disjoint:
    \begin{align*}
      \forall u \in V,
      \forall e_i, e_j \in E_u
      \colon
      e_{i, \form} \land e_{j, \form} \implies \bot
    \end{align*}

  \item[(2)]
    The disjunction of each edge in a tail set is a tautology:
    \begin{align*}
      \forall u \in V
      \colon
      \parens{\bigvee_{e \in E_u} e_{\form}} \implies \top
    \end{align*}
\end{enumerate}
$\square$
\end{definition}

Here, every vertex corresponds to some display.
Every edge $e$ is intended to represent an action, and the associated
formula $e_{\form}$ attached to each edge is intended ot capture the
logical conditions that must be satisfied when the action is performed
so that the transition may take place.
We require that the formula associated for each action be disjoint logical
formulae, meaning that they are not mutually satisfiable.
This ensures uniqueness of action.


\begin{example}[Simple UI]
Testing the limits of our \LaTeX{} powers, we bring you this example.
Here, the application consists of three displays, each with tree elements:

\begin{itemize}
  \item
    A {\color{blue} blue $n$-value label} that shows the global value of $n$.

  \item
    A {\color{green} green action buton} that modifies $n$ according
    to its description.

  \item
    A {\color{red} red warp button} that moves between displays.
    Sometimes crashes.
\end{itemize}

I think the {\color{green} green color} actually hurts my eyes to read.

\begin{minipage}{0.45\textwidth}
  \begin{center}
  \begin{tikzpicture}
    \draw (0.0, 0.0) -- (2.0, 0.0) -- (2.0, 3.5) -- (0.0, 3.5) -- (0.0, 0.0);
    \draw (2.5, 0.0) -- (4.5, 0.0) -- (4.5, 3.5) -- (2.5, 3.5) -- (2.5, 0.0);
    \draw (5.0, 0.0) -- (7.0, 0.0) -- (7.0, 3.5) -- (5.0, 3.5) -- (5.0, 0.0);

    \node[] at (1.0, 3.0) {{\small Display A}};
    \node[] at (3.5, 3.0) {{\small Display B}};
    \node[] at (6.0, 3.0) {{\small Display C}};

    \node[fill=blue!20] at (1.0, 2.2) {{\small $n$ value}};
    \node[fill=blue!20] at (3.5, 2.2) {{\small $n$ value}};
    \node[fill=blue!20] at (6.0, 2.2) {{\small $n$ value}};

    \node[fill=green!20,draw,rounded corners] at (1.0, 1.3) {$n + 1$};
    \node[fill=green!20,draw,rounded corners] at (3.5, 1.3) {$n - 1$};
    \node[fill=green!20,draw,rounded corners] at (6.0, 1.3) {$n \times 3$};

    \node[fill=red!20,draw,rounded corners] at (1.0, 0.5) {{\small Warp!}};
    \node[fill=red!20,draw,rounded corners] at (3.5, 0.5) {{\small Warp!}};
    \node[fill=red!20,draw,rounded corners] at (6.0, 0.5) {{\small Warp!}};

    \node[] at (2.0, 5.0) {{\small Initial starting display}};

    \draw[->] (1.0, 4.7) -- (1.0, 3.7);

  \end{tikzpicture}
  \end{center}
\end{minipage}
\hfill
\begin{minipage}{0.5\textwidth}
\begin{pcode}
// Display A:
green: set n = n + 1
red:   if n mod 5 == 1 then go to B
       if n mod 5 == 2 then go to C
       otherwise do nothing
// Display B:
green: set n = n - 1
red:   if n mod 5 == 0 then go to A
       if n mod 5 == 2 then go to C
       otherwise do nothing
// Display C:
green: set n = n * 3
red:   if n mod 5 == 0 then go to A
       if n mod 5 == 1 then go to B
       otherwise CRASH
\end{pcode}
\end{minipage}

The application graph should then look something like:

\let\redP\undefined
\newcommand{\redP}{\ensuremath{{\color{red} \textit{red}}}}

\let\greenP\undefined
\newcommand{\greenP}{\ensuremath{{\color{green} \textit{green}}}}

\begin{center}
\begin{tikzpicture}
  [->,
   % >=stealth',
   shorten >=1pt,
   auto,
   node distance=3cm,
   semithick,
   state/.style={circle, draw, minimum size=1cm} 
  ]
  \node[state] (B) at (0, 1)  {B};
  \node[state] (C) at (12, 1) {C};
  \node[state] (A) at (6, 7)  {A};
  \node[state] (E) at (9, -1) {E};

  \path (A) edge [loop above] node
      {$\redP \land \mod{n}{5} \not\in \braces{1, 2}$} (A);
  
  \path (A) edge [bend right, left] node
      {$\redP \land \mod{n}{5} = 1$} (B);

  \path (A) edge [below] node
      {$\redP \land \mod{n}{5} = 2$} (C);

  \path (B) edge [loop below] node
      {$\redP \land \mod{n}{5} \not\in \braces{0, 2}$} (B);

  \path (B) edge [below] node
      {$\redP \land \mod{n}{5} = 0$} (A);

  \path (B) edge [bend right] node
      {$\redP \land \mod{n}{5} = 2$} (C);

  \path (C) edge [bend right, right] node
      {$\redP \land \mod{n}{5} = 0$} (A);

  \path (C) edge [above] node
      {$\redP \land \mod{n}{5} = 1$} (B);

  \path (C) edge [right] node
      {$\redP \land \mod{n}{5} \not\in \braces{0, 1}$} (E);
\end{tikzpicture}
\end{center}

What a mess, but I hope the idea is clear: the objective of the application
graph is to capture the notion of the conditions on which transitions are
made when UI actions are performed.
Here $\redP$ denotes the action of the red button getting pressed.
Here, we model all such actions as button presses, for the sake of simplicity.

We chose not to draw the green button presses $\greenP$ because otherwise
the graph would be super cluttered.
Actions that do not bring you to a new display are treated as self-loops.
We treat the error crashing as a separate display.
$\square$
\end{example}


\subsection{The Dangerous Game}



\subsection{Conclusion}


\printbibliography


\end{document}
