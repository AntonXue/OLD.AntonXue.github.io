\documentclass[12pt]{article}

% Packages
\usepackage[margin=5em]{geometry} % 1 cm = 2.84528 em
\usepackage[backend=bibtex]{biblatex}
\bibliography{sources}
% \nocite{*}

\usepackage{lipsum}

% Paragraphs
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

% Includes
\input{antonxue-lib.tex}
\input{op-lib.tex}


% Author
\title{Operator Automata Theory}
% \author{Anton Xue}
% \date{\today}
\date{}

% Document
\begin{document}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduciton}

The goal of operator automata theory is to view automata is to
view automata as homomorphisms between linear spaces.
In this sketch we develop the basic theory and preliminary results.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Preliminaries}

\begin{definition}[Monoid]
  A monoid \(\parens{M, \cdot, \one}\) consists of a set \(M\) for which:
  \begin{itemize}
    \item
      Monoid multiplication
      \(\type{\cdot}{M \times M}{M}\) is associative.

    \item
      The element \(\one \in M\) is the unique identity of multiplication.
  \end{itemize}
\end{definition}

\begin{definition}[Semiring]
  A semiring \(\parens{R, +, \cdot, \zero, \one}\) consists of a set \(R\)
  for which:
  \begin{itemize}
    \item
      Semiring multiplication \(\type{\cdot}{R \times R}{R}\)
      distributes over semiring addition \(\type{+}{R \times R}{R}\).

    \item
      \(\parens{R, +, \zero}\) is a commutative monoid.

    \item
      \(\parens{R, \cdot, \one}\) is a monoid.

    \item
      Multiplication by zero \(\zero\) annihilates \(R\).
  \end{itemize}
\end{definition}

\begin{definition}[Semimodule]
  For a semiring \(R\), a \(R\)-semimodule
  \(\parens{M, +, \times, \zero}\)
  is such that:
  \begin{itemize}
    \item
      \(\parens{M, +, \zero}\) is a commutative group.

    \item
      Scalar multiplication
      \(\type{\cdot}{R \times M}{M}\) is a semiring action on \(M\).

  \end{itemize}
\end{definition}


\begin{definition}[Field]
  A field \(\parens{K, +, \cdot, \zero, \one}\) is a set \(K\) such that:
  \begin{itemize}
    \item
      Field multiplication \(\type{\cdot}{K \times K}{K}\)
      distributes over field addition \(\type{+}{K \times K}{K}\).

    \item
      \(\parens{K, +, \zero}\) is a commutative group.

    \item
      \(\parens{K, \cdot, \one}\) is a commutative group.

    \item
      Multiplication by zero \(\zero\) annihilates \(K\).
  \end{itemize}
\end{definition}

\begin{definition}[Linear Space]
  For a field \(K\),
  a \(K\)-linear space \(\parens{V, +, \cdot, \zero}\) over a field \(K\)
  is a set such that:
  \begin{itemize}
    \item
      \(\parens{V, +, \zero}\) is a commutative group.

    \item
      Scalar multiplication
      \(\type{\cdot}{\K \times V}{V}\) is a field action on \(V\).

  \end{itemize}
\end{definition}


\begin{definition}[Linear Operator]
  For \(K\)-linear spaces \(V\) and \(W\), a linear operator
  \(\type{T}{V}{W}\) is a homomorphism.
\end{definition}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Operators}

\red{Text goes here}

\subsection{\(M\)-Semimodules and Operator Norms}
Let \(\Sigma\) be a finite set and
\(M\) to be the monoid finitely generated by \(\Sigma\):
\begin{align*}
  M = \parens{\Sigma, \cdot, \one}
\end{align*}

\begin{definition}[Normed Monoid]
  A normed monoid is a monoid \(M\) with a norm
  \(\type{\norm{\cdot}}{M}{\Rz}\).
\end{definition}

The canonical norm here is length.

We may extend monoids in general to define the notion of a \(M\)-semiring.
In particular,
\(M\)-semirings are defined with respect to a monoid \(M\),
and are generated from its power set \(\powset{M}\).

\begin{definition}[\(M\)-Semiring]
  Let \(M\) be a finitely generated monoid.
  A \(M\)-semiring \(R\) is a semiring such that:
  \begin{align*}
    R = \parens{\powset{M}, \cup, \cdot, \zero, \one}
  \end{align*}
  Where semiring addition is set union \(\cup\) with identity \(\zero\),
  and semiring multiplication \(\cdot\) and identity \(\one\)
  are carried over from \(M\).
\end{definition}

As with the case of normed monoids,
we may extend this to normed \(M\)-semirings.
In particular, we pay special attention to \(p\)-norms.

\begin{definition}[\(M\)-Semiring \(p\)-Norm]
  Let \(M\) be a finitely generated and normed monoid.
  For \(1 \leq p \leq \infty\),
  a \(p\)-normed \(M\)-semiring is \(R\)
  is equipped with a norm \(\type{\norm{\cdot}_p}{R}{\Rz}\):
  \begin{align*}
    \norm{x}_{p} = \parens{\sum_{a \in x} \norm{a} ^p}^{1/p}
  \end{align*}
\end{definition}

The sum here utilizes the monoid norm.
Observe that because \(M\) is finitely generated,
each \(x \in R_M\) is therefore countable,
and hence so is the sum.
When \(p = \infty\), this is just a \(\sup\) norm.
Similar definitions can be found in literature~\cite{kudlek2000lemmata}.

Extending \(M\)-semirings,
we define \(\parens{M, n}\)-semimodules:

\begin{definition}[\(\parens{M, n}\)-Semimodule]
  A \(\parens{M, n}\)-semimodule \(R ^n\)
  is a free semimodule generated by \(n\) isomorphic copies of
  the \(M\)-semiring \(R\).
\end{definition}

If \(x \in R ^n\), write \(x_i\) to denote the \(i\)th element from
\(R\) in some canonical representation of \(R ^n\).
Often this is just a row (horizontal) or column (vertical)
vector of length \(n\).

Again, we extend norms to \(\parens{M, n}\)-semimodules:

\begin{definition}[\(\parens{M, n}\)-Semimodule \(\parens{p, q}\)-Norm]
  Let \(R\) be a \(p\)-normed \(M\)-semiring.
  Let \(R ^n\) be a \(\parens{M, n}\)-semimodule
  and take \(1 \leq p, q \leq \infty\).
  A \(\parens{p, q}\)-normed \(\parens{M, n}\)-semimodule
  is a semimodule with norm \(\type{\norm{\cdot}_{p, q}}{R^n}{\Rz}\):
  \begin{align*}
    \norm{x}_{p, q}
      = \parens{\sum_{i = 1}^{n} \norm{x_i}_{p}^q}^{1 / q}
  \end{align*}
\end{definition}

When \(p = q = \infty\), these are just the \(\sup\)-norm.

The goal of operator automata theory is to view automatas
as linear transformations between linear spaces.
To that end, we consider how to embed an automata as a linear transformation.

\begin{definition}[Something something automata]
  Descriptive definition text goes here.
\end{definition}



\subsection{Examples}

\begin{example}
  Consider \(\Sigma = \braces{a, b, c}\),
  and a finite automata below:

  \begin{center}
  \begin{tikzpicture}
    [->,
     >=stealth',
     shorten >=1pt,
     auto,
     node distance=2cm,
     semithick,
     state/.style={circle, draw, minimum size=1cm} 
    ]
    \node[state] (Q1) at (0, 0) {\(q_1\)};
    \node[state] (Q2) at (3, 1.5) {\(q_2\)};
    \node[state] (Q3) at (3, -1.5) {\(q_3\)};
  

    \path (Q1) edge [] node
              {\(\braces{a, b}\)} (Q2);
    \path (Q2) edge [loop right] node
              {\(\braces{a}\)} (Q2);
    \path (Q2) edge [] node
              {\(\braces{b}\)} (Q3);
    \path (Q3) edge [loop right] node
              {\(\braces{a, c}\)} (Q3);
    \path (Q3) edge [] node
              {\(\braces{c}\)} (Q1);
  \end{tikzpicture}
  \end{center}
  There are a few things to note in our model:
  \begin{enumerate}
    \item[(1)]
      The automata is non-deterministic, because from \(q_3\),
      there are multiple transitions that may be taken.

    \item[(2)]
      We lack the notion of a start and final state.
      Rather, every state is treated as both start and final in
      this perspective to make embedding slightly easier.
  \end{enumerate}
  To embed this into our model in several steps.
  First, take \(M\) to be the monoid generated by \(\Sigma\),
  where monoid multiplication is taken to be string concatenation,
  and unit \(1\) is aliased as \(\varepsilon\) the empty string.
  \begin{align*}
    M = \parens{\Sigma, \cdot, 1}
  \end{align*}
  The \(M\)-semiring is generated using the powersets of \(M\),
  where the unit of addition \(0\) is equivalent to the
  empty set \(\emptyset\):
  \begin{align*}
    R = \parens{\powset{M}, \cup, \cdot, 0, 1}
  \end{align*}
  To demonstrate a better picture of how this works, we construct a
  transition matrix \(A\) for the automata
  that acts on the \(\parens{M, 3}\)-semimodule.
  Here we have \(3\) because there are \(3\) states.
  Let \(A_{i, j}\) denote the transition set from state \(i\) to
  state \(j\).
  \begin{align*}
    A =
      \begin{bmatrix}
        0 & \braces{a, b} & 0 \\
        0 & \braces{a} & \braces{b} \\
        \braces{c} & 0 & \braces{a, c}
      \end{bmatrix}
  \end{align*}
  In order to perform string concatenation towards the right,
  transition matrices act by right-matrix multiplication.
  That is, if \(v \in R^3\) is the initial (row) vector,
  then the subsequent state is \(v A\).

  To briefly demonstrate, two transitions of the matrix \(A\) appears as
  follows:
  \begin{align*}
    A^2 =
      \begin{bmatrix}
        0 & \braces{a, b} & 0 \\
        0 & \braces{a} & \braces{b} \\
        \braces{c} & 0 & \braces{a, c}
      \end{bmatrix} 
      \begin{bmatrix}
        0 & \braces{a, b} & 0 \\
        0 & \braces{a} & \braces{b} \\
        \braces{c} & 0 & \braces{a, c}
      \end{bmatrix}
      =
      \begin{bmatrix}
        0 & \braces{aa, ba} & \braces{ab, bb} \\
        \braces{bc} & \braces{aa} & \braces{ab, ba, bc} \\
        \braces{ac, cc} & \braces{ca, cb} & \braces{aa, ac, ca, cc}
      \end{bmatrix}
  \end{align*}
  In general, from graph theory, \(A^k\) denotes the \(k\)th consecutive
  transition using \(A\),
  and each entry \(A^k _{i, j}\) is the set of strings that will
  get from state \(q_i\) to \(q_j\) in \(k\) steps.

\end{example}




\printbibliography

\end{document}

