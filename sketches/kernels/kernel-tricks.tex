\documentclass[12pt]{article}

% Packages
\usepackage[margin=5em]{geometry} % 1 cm = 2.84528 em
\usepackage[backend=bibtex]{biblatex}
\usepackage{xcolor}
\bibliography{sources}
% \nocite{*}

\usepackage{lipsum}

% Paragraphs
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

% Includes
\input{antonxue-lib.tex}
\input{ker-lib.tex}


% Author
\title{Kernel Methods and Automata}
\author{Anton Xue}
% \date{\today}
\date{}

% Document
\begin{document}
\maketitle

\section{Introduction}
In this sketch we study the relation between graph kernels and
finite state machines.
We study previous work in algebraic formulation for automata theory
and kernel methods, with an interest in how these techniques
may be extended to formal methods.



\section{Preliminaries}


\subsection{Algebraic Automata Theory}
Previous work in formulation in algebraic foundations for automata
theory exist in literature~\cite{kuich2012semirings},
and much of our notation is taken from~\cite{cortes2004rational}.
We overload notation for addition (\(+\)) and multiplication (\(\cdot\))
in algebraic structures when possible to avoid clutter.
Similarly, the additive identity (\(0\)) and multiplicative identity (\(1\))
are also overloaded when possible.

\begin{definition}[Monoid]
  A monoid is an algebraic structure \(\parens{\mbb{K}, \cdot, 1}\) where:
  
  \begin{itemize}
    \item
      \(\mbb{K}\) is closed under monoid multiplication
      \(\type{\cdot}{\mbb{K} \times \mbb{K}}{\mbb{K}}\).

    \item
      \(1\) is the multiplicative identity.

  \end{itemize}

  When possible, we elide the \(\cdot\) in monoid multiplication to write
  \(ab\) instead of \(a \cdot b\).
  When multiplication \(\cdot\) is commutative,
  the system is known as a commutative monoid.
\end{definition}


\begin{definition}[Semiring]
  A semiring \(\parens{\mbb{K}, +, \cdot, 0, 1}\) is a system where:

  \begin{itemize}
    \item
      Semiring addition is a commutative monoid
      \(\parens{\mbb{K}, +, 0}\).

    \item
      Semiring multiplication
      \(\parens{\mbb{K}, \cdot, 1}\) is a monoid.

    \item
      \(0\) annihilates semiring multiplication.
  \end{itemize}

\end{definition}

A weighted finite state transducer (WFST) is a very
general transition system defined
using a semiring to specify transition weights.


\begin{definition}[Weighted Finite State Transducer]
  A weighted finite state transducer over a semiring \(\mbb{K}\) is
  a system
  \(\parens{\Sigma_I, \Sigma_O, Q, I, F, \Delta, \lambda, \rho}\) where:

  \begin{itemize}
    \item
      \(\Sigma_I\) is a finite input alphabet.

    \item
      \(\Sigma_O\) is a finite output alphabet.

    \item
      \(Q\) is a finite set of states.

    \item
      \(I \subseteq Q\) is the set of starting states.

    \item
      \(F \subseteq Q\) is the set of final states.

    \item
      \(\Delta \subseteq
          Q \times
          \parens{\Sigma_I \cup \braces{\varepsilon}} \times
          \mbb{K} \times
          \parens{\Sigma_O \cup \braces{\varepsilon}} \times
          Q \)
      is the transition function weighted by \(\mbb{K}\).
        
    \item
      \(\type{\lambda}{I}{\mbb{K}}\) is the initial state weight function.

    \item
      \(\type{\rho}{F}{\mbb{K}}\) is the final state weight function.

    \end{itemize}

    Note that the transition function \(\Delta\) is defined to
    permit non-deterministic behavior by default.
\end{definition}

It should be noted that \(\Sigma_I\) and \(\Sigma_O\) can be
seen as the generators of the free monoids
\(\Sigma_I ^\star\) and \(\Sigma_O ^\star\),
which represents the set of all strings over
\(\Sigma_I\) and \(\Sigma_O\) respectively.

Although we are not yet interested in the full generality that
a WFST offers, it is still nice to see what is available to us
in terms of abstraction.

A special case of WFSTs that we are interested in
are non-deterministic finite automata,
whose specification in terms of WSFTs
is by Cortes~\cite{cortes2004rational}.
We introduce a simplified structure.

\begin{definition}[Non-deterministic Finite Automata]
  A non-deterministic finite automata is a system
  \(\parens{\Sigma, Q, \Delta, I, F}\) where:

  \begin{enumerate}
    \item
      \(\Sigma\) is a finite alphabet.

    \item
      \(Q\) is a finite set of states.

    \item
      \(\Delta \subseteq Q \times \Sigma \times Q\)
      is the transition function.

    \item
      \(I \subseteq Q\) is the set of initial states.

    \item
      \(F \subseteq Q\) is the set of final states.

  \end{enumerate}
\end{definition}

We do not permit \(\varepsilon\)-transitions in our definition,
which can be eliminated anyways~\cite{savage1998models}.



\subsection{Reproducing Kernel Hilbert Spaces}

Inner products spaces are nice because they allow us to measure projection.
Additionally, an inner product induces a norm, from which a metric,
and thus topology, can also be created.

\begin{definition}[Hilbert Space]
  A Hilbert space is a inner product space that is complete with respect
  to the metric induced by its inner product.
\end{definition}

If \(\mcal{H}\) is a Hilbert space,
write
\(\type{\angles{\cdot, \cdot}_{\mcal{H}}}{\mcal{H} \times \mcal{H}}{\R}\)
to denote its inner product.
We drop the subscript when context is clear,
and remark that another option is for complex-valued inner products.

A special type of Hilbert spaces are known as
reproducing kernel Hilbert spaces~\cite{berlinet2011reproducing}.
In short,
these are Hilbert spaces with a special function known
as the reproducing kernel.


\begin{definition}[Reproducing Kernel]
  Let \(\mcal{H}\) be a Hilbert space.
  A reproducing kernel is a function
  \(\type{k}{\mcal{H} \times \mcal{H}}{\R}\)
  that satisfies the property
  \begin{align*}
    f\parens{x} = \angles{f, k\parens{x, \cdot}}_H
  \end{align*}
  for all \(f \in \mcal{H}\).
\end{definition}

A reproducing Kernel hilbert space can be induced by the existence
of a kernel function (not to be confused with the reproducing kernel).
This type of kernel function can be defined over general sets,
and provides a way of taking inner products by embedding them
into a Hilbert spcae.

\begin{definition}[Kernel]
  Let \(\mcal{X}\) be a set.
  A function \(\type{k}{\mcal{X} \times \mcal{X}}{\R}\) if:

  \begin{enumerate}
    \item
      \(k\parens{x, y} = k\parens{y, x}\) for all \(x, y \in \mcal{X}\).
      This is known as symmetric.

    \item
      If for all \(x_1, x_2, \ldots, x_n \in \mcal{X}\)
      the Gram matrix \(K\)
      defined by:
      \begin{align*}
        K_{i, j} = k\parens{x_i, x_j}
      \end{align*}
      is positive semi-definite.

  \end{enumerate}

\end{definition}

Given a set \(\mcal{X}\) and a kernel
\(\type{k}{\mcal{X} \times \mcal{X}}{\R}\),
one can generate a Hilbert space.
Define a ``feautre map'' \(\type{\varphi}{\mcal{X}}{\R^{\mcal{X}}}\)
as follows:
\begin{align*}
  \varphi\parens{x} = k\parens{x, \cdot}
\end{align*}
Then \(\varphi\) maps each element of \(\mcal{X}\)
into a Hilbert space \(\mcal{H}\) consisting of the closure of
the span of functions \(\type{f}{\mcal{X}}{\R}\):
\begin{align*}
  \mcal{H} =
    \overline{\vspan\braces{\type{f}{\mcal{X}}{\R}}}
    = \overline{
        \braces{
          \sum_{i = 1}^{n} a_i k\parens{\cdot, x_i}
            \st n \in \N, x_i \in \mcal{X}, a_i \in \R}}
\end{align*}
Consider two functions \(f, g \in \mcal{H}\) which would have form:
\begin{align*}
  f\parens{x} = \sum_{i \in I} a_i k\parens{x, u_i}
  \qquad \qquad
  g\parens{x} = \sum_{j \in J} b_j k\parens{x, v_j}
\end{align*}
where each \(u_i, v_j \in \mcal{X}\).
Note that the summation may be infinite over the index sets \(I\)
and \(J\) may be infinite, since Hilbert spaces are complete with
respect to the norm induced by the inner product.
The inner product between \(f\) and \(g\) is then defined as:
\begin{align*}
  \angles{f, g}
    = \angles{\sum_{i \in I} a_i k\parens{\cdot, u_i},
              \sum_{j \in J} b_i k\parens{\cdot, v_j}}
    = \sum_{i \in I} \sum_{j \in J} a_i b_j k\parens{u_i, v_j}
\end{align*}
This is further described and proven in previous
work~\cite{cortes2004rational, vishwanathan2010graph}.



\section{Automata Embeddings}



\section{Bounding Inner Products}



\printbibliography


\end{document}


